"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
map_func <- function(i) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
inner_func <- i
output <-  function(...) {
# map function
res <- inner_func(...)
return(res)
}
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(output)
}
func_list <- map(map_list, function(i) map_func(i)) %>% stats::setNames(mapper_list)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
#' @rdname future_mapper
#' @export
future_mapper1 <- function(...) {
}
future_mapper1()
#' @rdname future_mapper
#' @export
future_mapper1 <- function(...) {
future_mapper1()
}
#' @rdname future_mapper
#' @export
future_mapper1 <- function(...) {
}
future_mapper1()
View(future_mapper)
# 2. future_mapper-----------------------------------
future_mapper <- function(...) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
map_func <- function(i) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
inner_func <- i
output <-  function(...) {
# map function
res <- inner_func(...)
return(res)
}
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(output)
}
func_list <- map(map_list, function(i) map_func(i)) %>% stats::setNames(mapper_list)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
future_mapper()
# 2. future_mapper-----------------------------------
future_mapper <- function(...) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
map_func <- function(i) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
inner_func <- i
output <-  function(...) {
# map function
res <- inner_func(...)
return(res)
}
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(output)
}
func_list <- map(map_list, function(i) map_func(i)) %>% stats::setNames(mapper_list)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
#' @rdname future_mapper
#' @export
future_mapper1 <- function(...) {
}
future_mapper1()
#' @rdname future_mapper
#' @export
future_mapper1 <- function(...) {
}
future_mapper1()
#' @rdname future_mapper
#' @export
future_mapper1 <- future_mapper()
library(tidyverse)
#' @rdname future_mapper
#' @export
future_mapper1 <- future_mapper()
library(devtools)
load_all()
library(devtools)
load_all()
rlang::last_trace()
# 1. future_imapper----------------------------------
future_imapper_template <- function(...) {
imap_list <- c(furrr::future_imap,
furrr::future_imap_chr,
furrr::future_imap_dbl,
furrr::future_imap_dfc,
furrr::future_imap_dfr,
furrr::future_imap_int,
furrr::future_imap_lgl)
imapper_list <- c("future_imapper",
"future_imapper_chr",
"future_imapper_dbl",
"future_imapper_dfc",
"future_imapper_dfr",
"future_imapper_int",
"future_imapper_lgl")
# imap function------------------------
imap_func <- function(i) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
inner_func <- i
output <-  function(...) {
# imap function
res <- inner_func(...)
return(res)
}
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(output)
}
func_list <- map(imap_list, function(i) imap_func(i)) %>% stats::setNames(imapper_list)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
#' @rdname future_imapper
#' @export
future_imapper <- function(...) {
}
future_imapper()
#' @rdname future_imapper
#' @export
future_imapper <- function(...) {
}
future_imapper()
library(devtools)
load_all()
library(devtools)
load_all()
load_all()
load_all()
#' @rdname future_imapper
#' @export
future_imapper <- future_imapper_template()
# 1. future_imapper----------------------------------
#' @rdname future_imapper_template
#' @export
future_imapper_template <- function(...) {
imap_list <- c(furrr::future_imap,
furrr::future_imap_chr,
furrr::future_imap_dbl,
furrr::future_imap_dfc,
furrr::future_imap_dfr,
furrr::future_imap_int,
furrr::future_imap_lgl)
imapper_list <- c("future_imapper",
"future_imapper_chr",
"future_imapper_dbl",
"future_imapper_dfc",
"future_imapper_dfr",
"future_imapper_int",
"future_imapper_lgl")
# imap function------------------------
imap_func <- function(i) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
inner_func <- i
output <-  function(...) {
# imap function
res <- inner_func(...)
return(res)
}
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(output)
}
func_list <- map(imap_list, function(i) imap_func(i)) %>% stats::setNames(imapper_list)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
#' @rdname future_imapper
#' @export
future_imapper <- function(...) {
}
#' @rdname future_imapper
#' @export
future_imapper <- function(...) {
}
load_all()
library(tidyverse)
load_all()
load_all()
load_all()
load_all()
# 5. future_invoke_mapper----------------------------------
future_invoke_mapper_template <- function(...) {
invoke_map_list <- c(furrr::future_invoke_map,
furrr::future_invoke_map_chr,
furrr::future_invoke_map_dbl,
furrr::future_invoke_map_dfc,
furrr::future_invoke_map_dfr,
furrr::future_invoke_map_int,
furrr::future_invoke_map_lgl)
invoke_mapper_list <- c("future_invoke_mapper",
"future_invoke_mapper_chr",
"future_invoke_mapper_dbl",
"future_invoke_mapper_dfc",
"future_invoke_mapper_dfr",
"future_invoke_mapper_int",
"future_invoke_mapper_lgl")
# map function------------------------
invoke_mapper_func <- function(i) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
inner_func <- i
output <-  function(...) {
# map function
res <- inner_func(...)
return(res)
}
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(output)
}
func_list <- map(invoke_map_list, function(i) invoke_mapper_func(i)) %>% stats::setNames(invoke_mapper_list)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
??furrr::future_invoke_map_chr
load_all()
load_all()
load_all()
source("template.R")
load_all()
document()
check()
remove.packages("mapper", lib="~/R/x86_64-pc-linux-gnu-library/4.3")
devtools::install_github("haihuilab/mapper")
library(devtools)
load_all()
document()
source("template.R")
document()
library(tidyverse)
document()
check()
#' @rdname future_imapper
#' @export
future_imapper <- function() {
}
# 1. future_imapper----------------------------------
#' @export
future_imapper_template <- function(...) {
imap_list <- c(furrr::future_imap,
furrr::future_imap_chr,
furrr::future_imap_dbl,
furrr::future_imap_dfc,
furrr::future_imap_dfr,
furrr::future_imap_int,
furrr::future_imap_lgl)
imapper_list <- c("future_imapper",
"future_imapper_chr",
"future_imapper_dbl",
"future_imapper_dfc",
"future_imapper_dfr",
"future_imapper_int",
"future_imapper_lgl")
# imap function------------------------
imap_func <- function(i) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
inner_func <- i
output <-  function(...) {
# imap function
res <- inner_func(...)
return(res)
}
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(output)
}
func_list <- map(imap_list, function(i) imap_func(i)) %>% stats::setNames(imapper_list)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
#' @rdname future_imapper
#' @export
future_imapper <- function() {
}
future_imapper()
library(devtools)
load_all()
library(devtools)
use_r("template")
load_all()
load_all()
# 1. future_imapper----------------------------------
#' @export
future_imapper_template <- function(...) {
imap_list <- c(furrr::future_imap,
furrr::future_imap_chr,
furrr::future_imap_dbl,
furrr::future_imap_dfc,
furrr::future_imap_dfr,
furrr::future_imap_int,
furrr::future_imap_lgl)
imapper_list <- c("future_imapper",
"future_imapper_chr",
"future_imapper_dbl",
"future_imapper_dfc",
"future_imapper_dfr",
"future_imapper_int",
"future_imapper_lgl")
# imap function------------------------
imap_func <- function(i) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
inner_func <- i
output <-  function(...) {
# imap function
res <- inner_func(...)
return(res)
}
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(output)
}
func_list <- map(imap_list, function(i) imap_func(i)) %>% stats::setNames(imapper_list)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
#' @rdname future_imapper
#' @export
future_imapper <- function(...) {
return(res)
}
future_imapper()
#' @rdname future_imapper
#' @export
future_imapper <- function(...) {
# return(res)
}
future_imapper()
#' @rdname future_imapper
#' @export
future_imapper <- function(...) {
}
future_imapper()
future_imapper
future_imapper_template()
library(devtools)
load_all()
check()
load_all()
check()
check()
install()
document()
library(devtools)
load_all()
check()
document()
document()
document()
load_all()
load_all()
load_all()
load_all()
library(devtools)
load_all()
check()
load_all()
check()
document()
document()
check()
document()
check()
document()
check()
check()
document()
check()
W  checking for missing documentation entries doc...‘future_imapper_template’
document()
check()
document()
document()
load_all()
document()
check()
load_all()
load_all()
# 1. future_imapper----------------------------------
#' future_imapper_template
#' @export
future_imapper_template <- function(...) {
imap_list <- c(furrr::future_imap,
furrr::future_imap_chr,
furrr::future_imap_dbl,
furrr::future_imap_dfc,
furrr::future_imap_dfr,
furrr::future_imap_int,
furrr::future_imap_lgl)
imapper_list <- c("future_imapper",
"future_imapper_chr",
"future_imapper_dbl",
"future_imapper_dfc",
"future_imapper_dfr",
"future_imapper_int",
"future_imapper_lgl")
# imap function------------------------
imap_func <- function(i) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
inner_func <- i
output <-  function(...) {
# imap function
res <- inner_func(...)
return(res)
}
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(output)
}
func_list <- map(imap_list, function(i) imap_func(i)) %>% stats::setNames(imapper_list)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
load_all()
document()
check()
library(tidyverse)
walk("future", use_package)
check()
load_all()
check()
document()
library(devtools)
check()
install()
library(devtools)
load_all()
load_all()
document()
document()
document()
load_all()
library(devtools)
load_all()
load_all()
load_all()
document()
rlang::last_trace()
