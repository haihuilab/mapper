future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
future_mapper <- function(...) {
flag <- FALSE
if (!flag) {
future_mapper_template("future_mapper")
flag <- TRUE
} else {
future_mapper(...)
}
}
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
future_mapper_template("future_mapper")
future_mapper_template <- function(arg) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
mapper_func <- function(i) {
inner_func <- i
output <-  function(...) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
# map function
res <- inner_func(...)
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(res)
}
return(output)
}
func_list <- map(map_list[which(mapper_list == arg)], function(i) mapper_func(i)) %>% stats::setNames(arg)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
future_mapper_template("future_mapper")
library(tidyverse)
future_mapper_template("future_mapper")
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
debug(future_mapper)
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
undebug(future_mapper)
future_mapper <- function(...) {
flag <- FALSE
if (!flag) {
future_mapper_template("future_mapper")
flag <- TRUE
} else {
future_mapper(...)
}
}
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
undebug(future_mapper)
undebug(future_mapper_template)
future_mapper <- function(...) {
if (!exists("future_mapper")) {
future_mapper_template("future_mapper")
future_mapper(...)
} else {
future_mapper(...)
}
}
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
!exists("future_mapper", mode = "function")
!exists("future_mapper"
)
future_mapper_template <- function(arg) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
mapper_func <- function(i) {
inner_func <- i
output <-  function(...) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
# map function
res <- inner_func(...)
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(res)
}
return(output)
}
func_list <- map(map_list[which(mapper_list == arg)], function(i) mapper_func(i)) %>% stats::setNames(arg)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
future_mapper <- function(...) {
if (!exists("future_mapper", mode = "function")) {
future_mapper_template("future_mapper")
future_mapper(...)
} else {
future_mapper(...)
}
}
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
debug(future_mapper)
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
undebug(future_mapper)
future_mapper <- function(...) {
if (!exists("future_mapper", mode = "function")) {
future_mapper_template("future_mapper")
future_mapper()
} else {
future_mapper()
}
}
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
future_mapper_template <- function(arg) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper1",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
mapper_func <- function(i) {
inner_func <- i
output <-  function(...) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
# map function
res <- inner_func(...)
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(res)
}
return(output)
}
func_list <- map(map_list[which(mapper_list == arg)], function(i) mapper_func(i)) %>% stats::setNames(arg)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
future_mapper <- function(...) {
if (!exists("future_mapper", mode = "function")) {
future_mapper_template("future_mapper1")
future_mapper1(...)
} else {
future_mapper1(...)
}
}
# Example
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
future_mapper <- function(...) {
if (!exists("future_mapper1", mode = "function")) {
future_mapper_template("future_mapper1")
future_mapper1(...)
} else {
future_mapper1(...)
}
}
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper1(rnorm, n = 10, .options = furrr_options(seed = 1233))
future_mapper_template("future_mapper1")
future_mapper_template <- function(arg) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
mapper_func <- function(i) {
inner_func <- i
output <-  function(...) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
# map function
res <- inner_func(...)
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(res)
}
return(output)
}
func_list <- map(map_list[which(mapper_list == arg)], function(i) mapper_func(i)) %>% stats::setNames(arg)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
future_mapper1 <- function(...) {
if (!exists("future_mapper", mode = "function")) {
future_mapper_template("future_mapper")
future_mapper(...)
} else {
future_mapper(...)
}
}
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper1(rnorm, n = 10, .options = furrr_options(seed = 1233))
future_mapper1 <- function(...) {
if (!exists("future_mapper1", mode = "function")) {
future_mapper_template("future_mapper")
future_mapper(...)
} else {
future_mapper(...)
}
}
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper1(rnorm, n = 10, .options = furrr_options(seed = 1233))
debug(future_mapper1)
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper1(rnorm, n = 10, .options = furrr_options(seed = 1233))
#' @export
future_mapper <- function(...) {
future_mapper_template("future_mapper")
future_mapper(...)
}
# Example
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
# Example
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
# Example
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
# Example
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapp(rnorm, n = 10, .options = furrr_options(seed = 1233))
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_map(rnorm, n = 10, .options = furrr_options(seed = 1233))
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_map(rnorm, n = 10, .options = furrr_options(seed = 1233))
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_map(rnorm, n = 10, .options = furrr_options(seed = 1233))
debug(future_mapper)
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_map(rnorm, n = 10, .options = furrr_options(seed = 1233))
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
debug(future_mapper)
future_mapper <- function(...) {
future_mapper_template("future_mapper")
future_mapper(...)
}
debug(future_mapper)
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
future_mapper_template <- function(arg) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
mapper_func <- function(i) {
inner_func <- i
output <-  function(...) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
# map function
res <- inner_func(...)
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(res)
}
return(output)
}
func_list <- map(map_list[which(mapper_list == arg)], function(i) mapper_func(i)) %>% stats::setNames(arg)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
debug(future_mapper)
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
undebug(future_mapper)
library(devtools)
load_all()
document()
check()
use_version(1.0.2)
use_version("1.0.2")
use_version("patch")
use_version("patch")
future_mapper_template <- function(arg) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
mapper_func <- function(i) {
inner_func <- i
output <-  function(...) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
# map function
res <- inner_func(...)
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(res)
}
return(output)
}
func_list <- map(map_list[which(mapper_list == arg)], function(i) mapper_func(i)) %>% stats::setNames(arg)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
future_mapper <- function() {
future_mapper_template("future_mapper")
future_mapper(...)
}
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
remove.packages("mapper", lib="~/R/x86_64-pc-linux-gnu-library/4.3")
