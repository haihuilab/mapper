plan(sequential)
# gc()
}
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233)) %>%
future_map_dbl(mean)
# 1. future_mapper:future_map------------------------
future_mapper <- function(...) {
plan(multisession, workers = 4)
options(future.globals.maxSize = 5000000000)
future_map(...)
# shut down multicore and clear cache
# plan(sequential)
# gc()
}
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233)) %>%
future_map_dbl(mean)
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 133)) %>%
future_map_dbl(mean)
library(future)
# Define a function that takes some time to execute
my_function <- function() {
Sys.sleep(5)  # Simulate some time-consuming task
return("Finished executing")
}
# Create a future for the function
future_result <- future({ my_function() })
# Wait for the future to be finished
wait(future_result)
# 1. future_mapper:future_map------------------------
future_mapper <- function(...) {
plan(multisession, workers = 4)
options(future.globals.maxSize = 5000000000)
future_map(...)
Sys.sleep(5)
# shut down multicore and clear cache
plan(sequential)
gc()
}
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 133)) %>%
future_map_dbl(mean)
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233)) %>%
future_map_dbl(mean)
# 1. future_mapper:future_map------------------------
future_mapper <- function(...) {
plan(multisession, workers = 4)
options(future.globals.maxSize = 5000000000)
future_map(...)
Sys.sleep(5)
# shut down multicore and clear cache
plan(sequential)
# gc()
}
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233)) %>%
future_map_dbl(mean)
# 1. future_mapper:future_map------------------------
future_mapper <- function(...) {
plan(multisession, workers = 4)
options(future.globals.maxSize = 5000000000)
res <- future_map(...)
return(res)
# shut down multicore and clear cache
plan(sequential)
gc()
}
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233)) %>%
future_map_dbl(mean)
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 133)) %>%
future_map_dbl(mean)
source("~/software/R_packages/maper/R/future_mapper (copy).R", echo=TRUE)
# 2. future_mapper_chr:future_map_chr------------------------
map_func <- function(i) {
inner_func <- i
output <-  function(...) {
# map function
res <- inner_func(...)
return(res)
# shut down multicore and clear cache
plan(sequential)
gc()
}
return(output)
}
func_list <- map(map_list, function(i) map_func(i)) %>% setNames(mapper_list)
View(func_list)
func_list[["future_mapper"]]
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233)) %>%
future_map_dbl(mean)
source("~/software/R_packages/maper/R/future_mapper (copy).R", echo=TRUE)
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 123)) %>%
future_map_dbl(mean)
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1243)) %>%
future_map_dbl(mean)
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1243)) %>%
future_mapper_dbl(mean)
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1242343)) %>%
future_mapper_dbl(mean)
1:10 %>%
future_map(rnorm, n = 10, .options = furrr_options(seed = 1242343)) %>%
future_map_dbl(mean)
source("~/software/R_packages/maper/R/future_mapper (copy).R", echo=TRUE)
source("~/software/R_packages/maper/R/future_mapper (copy).R", echo=TRUE)
source("~/software/R_packages/maper/R/future_mapper (copy).R", echo=TRUE)
# shut down multicore and clear cache
plan(sequential)
source("~/software/R_packages/maper/R/future_mapper (copy).R", echo=TRUE)
source("~/software/R_packages/maper/R/future_mapper (copy).R", echo=TRUE)
source("~/software/R_packages/maper/R/future_mapper (copy).R", echo=TRUE)
source("~/software/R_packages/maper/R/future_mapper (copy).R", echo=TRUE)
library(furrr)
??future_pmap
??future_pmap
library(furrr)
library(devtools)
load_all()
check()
library(furrr)
check()
use_mit_license()
document()
walk("furrr", use_package)
walk("tidyverse", use_package)
check()
library(tidyverse)
check()
check()
check()
walk("dplyr", use_package)
check()
check()
walk("purrr", use_package)
use_github()
usethis::use_git_remote("origin", url = NULL, overwrite = TRUE)
use_github()
gh_token_help()
gitcreds::gitcreds_set()
use_github()
library(devtools)
load_all()
install()
document()
create_package()
create_package("/home/figo/software/R_packages/mapper3")
use_testthat()
use_test(mapper)
check()
use_test()
check()
document()
R CMD build mapper
document()
check()
check()
check()
check()
check()
install()
load_all()
check()
check()
check()
check()
check()
document()
check()
load_all()
library(devtools)
load_all()
check()
document()
check()
use_mit_license()
install()
use_testthat()
use_test()
check()
library(devtools)
use_git()
use_r(mapper)
load_all()
check()
source("~/software/R_packages/mapper/R/future_imapper.R", echo=TRUE)
library(devtools)
load_all()
library(devtools)
load_all()
check()
document()
library(devtools)
load_all()
check()
document()
remove.packages("mapper", lib="~/R/x86_64-pc-linux-gnu-library/4.3")
load_all
library(devtools)
load_all()
check()
document()
walk("parallel", use_package)
library(tidyverse)
walk("parallel", use_package)
check()
use_testthat()
use_test(mapper)
use_test()
check()
install()
library(devtools)
load_all()
use_r(mapper)
check()
document()
library(tidyverse)
walk("dplyr", use_package)
check()
document()
check()
??stats::setNames
library(devtools)
load_all()
check()
??map
load_all()
check()
library(tidyverse)
walk("magrittr", use_package)
check()
document()
check()
document()
check()
install()
remove.packages("mapper", lib="~/R/x86_64-pc-linux-gnu-library/4.3")
# 2. future_mapper-----------------------------------
future_mapper <- function(...) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
map_func <- function(i) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
inner_func <- i
output <-  function(...) {
# map function
res <- inner_func(...)
return(res)
}
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(output)
}
func_list <- map(map_list, function(i) map_func(i)) %>% stats::setNames(mapper_list)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
#' @rdname future_mapper
#' @export
future_mapper <- function(...) {
}
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233)) %>%
future_map_dbl(mean)
# Example
library(tidyverse)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233)) %>%
future_map_dbl(mean)
library(purrr)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233)) %>%
future_map_dbl(mean)
library(furrr)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233)) %>%
future_map_dbl(mean)
#' @rdname future_mapper
#' @export
future_mapper <- function(...) {
}
# 2. future_mapper-----------------------------------
future_mapper <- function(...) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
map_func <- function(i) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
inner_func <- i
output <-  function(...) {
# map function
res <- inner_func(...)
return(res)
}
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(output)
}
func_list <- map(map_list, function(i) map_func(i)) %>% stats::setNames(mapper_list)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
#' @rdname future_mapper
#' @export
future_mapper1 <- function(...) {
}
future_mapper1()
#' @rdname future_mapper
#' @export
future_mapper1 <- function(...) {
future_mapper1()
}
#' @rdname future_mapper
#' @export
future_mapper1 <- function(...) {
}
future_mapper1()
View(future_mapper)
# 2. future_mapper-----------------------------------
future_mapper <- function(...) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
map_func <- function(i) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
inner_func <- i
output <-  function(...) {
# map function
res <- inner_func(...)
return(res)
}
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(output)
}
func_list <- map(map_list, function(i) map_func(i)) %>% stats::setNames(mapper_list)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
future_mapper()
# 2. future_mapper-----------------------------------
future_mapper <- function(...) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
map_func <- function(i) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
inner_func <- i
output <-  function(...) {
# map function
res <- inner_func(...)
return(res)
}
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(output)
}
func_list <- map(map_list, function(i) map_func(i)) %>% stats::setNames(mapper_list)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
#' @rdname future_mapper
#' @export
future_mapper1 <- function(...) {
}
future_mapper1()
#' @rdname future_mapper
#' @export
future_mapper1 <- function(...) {
}
future_mapper1()
#' @rdname future_mapper
#' @export
future_mapper1 <- future_mapper()
library(tidyverse)
#' @rdname future_mapper
#' @export
future_mapper1 <- future_mapper()
library(devtools)
load_all()
library(devtools)
load_all()
rlang::last_trace()
# 1. future_imapper----------------------------------
future_imapper_template <- function(...) {
imap_list <- c(furrr::future_imap,
furrr::future_imap_chr,
furrr::future_imap_dbl,
furrr::future_imap_dfc,
furrr::future_imap_dfr,
furrr::future_imap_int,
furrr::future_imap_lgl)
imapper_list <- c("future_imapper",
"future_imapper_chr",
"future_imapper_dbl",
"future_imapper_dfc",
"future_imapper_dfr",
"future_imapper_int",
"future_imapper_lgl")
# imap function------------------------
imap_func <- function(i) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
inner_func <- i
output <-  function(...) {
# imap function
res <- inner_func(...)
return(res)
}
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(output)
}
func_list <- map(imap_list, function(i) imap_func(i)) %>% stats::setNames(imapper_list)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
#' @rdname future_imapper
#' @export
future_imapper <- function(...) {
}
future_imapper()
#' @rdname future_imapper
#' @export
future_imapper <- function(...) {
}
future_imapper()
