# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
sdf
df
df
3e
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
q
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
q
undebug(ls)
?debug
undebug(future_mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
library(devtools)
load_all()
document()
library(devtools)
load_all()
document()
check()
check()
devtools::install_github("haihuilab/mapper")
library(tidyverse)
library(furrr)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
library(tidyverse)
library(furrr)
library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
rm(list = setdiff(ls(), future_imap)
)
rm(list = setdiff(ls(), future_mapper))
rm(list = setdiff(ls(), "future_mapper"))
library(devtools)
load_all()
devtools::install_github("haihuilab/mapper")
library(tidyverse)
library(furrr)
library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
remove.packages("mapper", lib="~/R/x86_64-pc-linux-gnu-library/4.3")
future_mapper_template <- function(...) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
map_func <- function(i) {
inner_func <- i
output <-  function(...) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
# map function
res <- inner_func(...)
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(res)
}
return(output)
}
func_list <- map(map_list, function(i) map_func(i)) %>% stats::setNames(mapper_list)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
future_mapper <- function(...) {
flag <- FALSE
if (!flag) {
future_mapper_template()
flag <- TRUE
} else {
future_mapper(...)
rm(list = ls(pattern = "function"))
}
}
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
rm(list = ls(pattern = "function"))
rm(list = ls(pattern = "function"))
# Retrieve the names of all functions in the current environment
function_names <- ls()[sapply(ls(), is.function)]
# Delete all functions
for (func_name in function_names) {
rm(list = func_name, envir = globalenv())
}
# Retrieve the names of all functions in the global environment
function_names <- ls(pos = "globalenv", mode = "function")
#'
#' @return
#' A vector the same length as .x.
#' future_mapper_template
#' @export
future_mapper_template <- function(...) {
future_mapper_template <- function(...) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
map_func <- function(i) {
inner_func <- i
output <-  function(...) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
# map function
res <- inner_func(...)
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(res)
}
return(output)
}
func_list <- map(map_list, function(i) map_func(i)) %>% stats::setNames(mapper_list)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
future_mapper <- function(...) {
flag <- FALSE
if (!flag) {
future_mapper_template()
flag <- TRUE
} else {
future_mapper(...)
rm(list = setdiff(ls(), "future_mapper"))
}
}
library(tidyverse)
library(furrr)
library(mapper)
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
rm(list = setdiff(ls(), "future_map"))
future_mapper_template <- function(...) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
map_func <- function(i) {
inner_func <- i
output <-  function(...) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
# map function
res <- inner_func(...)
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(res)
}
return(output)
}
func_list <- map(map_list, function(i) map_func(i)) %>% stats::setNames(mapper_list)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
future_mapper <- function(...) {
flag <- FALSE
if (!flag) {
future_mapper_template()
flag <- TRUE
} else {
future_mapper(...)
rm(list = setdiff(ls(), "future_mapper"))
}
}
future_mapper()
#'
#' @return
#' A vector the same length as .x.
#' future_mapper_template
#' @export
future_mapper_template <- function(arg = NULL) {
future_mapper_template <- function(arg = NULL) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
map_func <- function(i) {
inner_func <- i
output <-  function(...) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
# map function
res <- inner_func(...)
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(res)
}
return(output)
}
func_list <- map(map_list, function(i) map_func(i)) %>% stats::setNames(mapper_list)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
rm(list = setdiff(ls(), arg))
}
future_mapper <- function(...) {
flag <- FALSE
if (!flag) {
future_mapper_template(arg = "future_mapper")
flag <- TRUE
} else {
future_mapper(...)
rm(list = setdiff(ls(), "future_mapper"))
}
}
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
arg ="future_mapper"
rm(list = setdiff(ls(), arg))
func_list <- ls(pos = ".GlobalEnv", mode = "function")
func_list <- ls(pos = ".GlobalEnv", mode = "function")
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
#'
#' @return
#' A vector the same length as .x.
#' future_mapper_template
#' @export
future_mapper_template <- function(arg = NULL) {
future_mapper_template <- function(arg = NULL) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
map_func <- function(i) {
inner_func <- i
output <-  function(...) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
# map function
res <- inner_func(...)
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(res)
}
return(output)
}
func_list <- map(map_list[which(map_list == arg)], function(i) map_func(i)) %>% stats::setNames(mapper_list[arg])
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
rm(list = setdiff(ls(), arg))
}
future_mapper <- function(...) {
flag <- FALSE
if (!flag) {
future_mapper_template(arg = "future_mapper")
flag <- TRUE
} else {
future_mapper(...)
rm(list = setdiff(ls(), "future_mapper"))
}
}
future_mapper()
arg = "future_mapper"
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
map_list[which(map_list == arg)]
map_list(which(map_list == arg))
map_list(which(mapprt_list == arg)
)
which(mapprt_list == arg)
which(mappr_list == arg)
which(mapper_list == arg)
map_list(which(mapper_list == arg))
map_list[which(mapper_list == arg)]
mapper_list[arg]
#'
#' @return
#' A vector the same length as .x.
#' future_mapper_template
#' @export
future_mapper_template <- function(arg = NULL) {
future_mapper_template <- function(arg = NULL) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
map_func <- function(i) {
inner_func <- i
output <-  function(...) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
# map function
res <- inner_func(...)
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(res)
}
return(output)
}
func_list <- map(map_list[which(mapper_list == arg)], function(i) map_func(i)) %>% stats::setNames(arg)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
rm(list = setdiff(ls(), arg))
}
#' @export
future_mapper <- function(...) {
flag <- FALSE
if (!flag) {
future_mapper_template(arg = "future_mapper")
flag <- TRUE
} else {
future_mapper(...)
rm(list = setdiff(ls(), "future_mapper"))
}
}
future_map()
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
# Example
library(tidyverse)
library(furrr)
# library(mapper)
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
future_mapper_template <- function(arg = NULL) {
map_list <- c(furrr::future_map,
furrr::future_map_chr,
furrr::future_map_dbl,
furrr::future_map_dfc,
furrr::future_map_dfr,
furrr::future_map_int,
furrr::future_map_lgl,
furrr::future_walk)
mapper_list <- c("future_mapper",
"future_mapper_chr",
"future_mapper_dbl",
"future_mapper_dfc",
"future_mapper_dfr",
"future_mapper_int",
"future_mapper_lgl",
"future_mapper_walk")
# map function------------------------
map_func <- function(i) {
inner_func <- i
output <-  function(...) {
# Start multicore
future::plan(future::multisession, workers = parallel::detectCores()-2)
options(future.globals.maxSize = 5000000000)
# map function
res <- inner_func(...)
# shut down multicore and clear cache
future::plan(future::sequential)
gc()
return(res)
}
return(output)
}
func_list <- map(map_list[which(mapper_list == arg)], function(i) map_func(i)) %>% stats::setNames(arg)
# Extract the functions as individual ones
list2env(func_list, envir = .GlobalEnv)
}
future_mapper <- function(...) {
flag <- FALSE
if (!flag) {
future_mapper_template(arg = "future_mapper")
flag <- TRUE
} else {
future_mapper(...)
rm(list = setdiff(ls(), "future_mapper"))
}
}
# Remove cache when using furrr:map functions
1:10 %>%
future_mapper(rnorm, n = 10, .options = furrr_options(seed = 1233))
